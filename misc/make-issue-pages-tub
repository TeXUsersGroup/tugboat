#!/bin/sh
# $Id$
# Public domain.
# 
# Create files for Cadmus, per their ~tubprod/00/FileSpecs_2020.pdf doc.
# One file per page, with names in a specific format, grayscaled by default.
# Run from the top-level issue Makefile.
# Required option: --pubmonth NN (used in the filenames).
# Optional option: --colorpages "NNN NNN ..." (don't grayscale those pages).

colorpages=
pubmonth=

while test $# -gt 0; do
  if test "x$1" = x--pubmonth; then
    shift || exit 1
    if echo "$1" | grep -v '^[01][0-9]$' >/dev/null; then
      echo "$0: publication month must be between 01..12, not: $1" >&2
      exit 1
    fi
    if test "$1" -lt 1 || test "$1" -gt 12; then
      echo "$0: publication month must be between 01..12, not: $1" >&2
      exit 1
    fi
    pubmonth=$1
    shift

  elif test "x$1" = x--colorpages; then
    # we'll let the test below sort out incorrect values here.
    shift || exit 1
    colorpages=$1
    shift

  else
    echo "$0: unexpected argument: $1" >&2
    cat <<USAGE >&2
Usage: $0 --pubmonth NN [--colorpages "NNN NNN ..."]

Generate split fileset for Cadmus, from file CADMUS/issue.pdf.

Publication month is required, and must be exactly two digits.

If color pages are specified, each must be exactly three digits, with
leading zeros as necessary, and each must be present in issue.pdf.

This is invoked from the top-level issue Makefile; see there for more.
USAGE
    exit 1
  fi
done

if test -z "$pubmonth"; then
  echo "$0: publication month (01..12) must be specified." >&2
  exit 1
fi

# Little routine to return (expand to) the number of PDF pages in $1.
# 
# Here, and throughout the script, we intentionally do not quote the
# variables, since if there are unexpected filenames or other strings,
# an error from test or bash or whatever is desired.
pdfpagecount () {
  if test ! -s $1; then
    echo "$0: pdfpagecount argument not readable or empty: $1" >&2
    exit 1
  fi
  
  # without the -I, get permission error because of SAFER.
  # would be cleaner to switch to -dPDFINFO.
  # https://ghostscript.readthedocs.io/en/latest/Use.html#dpdfinfo
  gscmd="$gs -dNODISPLAY -dNOSAFER -I`dirname $1` \
             -c ($1) (r) file runpdfbegin pdfpagecount = quit"
  if ! $gscmd >/tmp/pdfpagecountout; then
    echo "$0: pdfpagecount failed: $1" >&2
    echo "$0: gscmd: $gscmd" >&2
    cat /tmp/pdfpagecountout >&2
    kill $$ # called from `...`, so exit doesn't exit
  else
    cat /tmp/pdfpagecountout
  fi
}

# if page count of $1 (a pdf) != $2, abort.
assert_pdfpagecount () {
  pdfcount=`pdfpagecount $1`
  if test -z "$pdfcount"; then
    echo "$0: (assert_pdfpagecount) pdfpagecount failed to count: $1" >&2
    exit 1
  fi
  if test $pdfcount -ne $2; then
    echo "$0: $pdfcount pages in $1, expected $2, goodbye." >&2
    exit 1
  fi
}

#
# We do some unusual Ghostscript calls, so don't use ps2pdf-tub.  But
# tell gs not to rotate our pages (e.g., tb132voss-hvfloat, but
# auto-rotation is a bad idea in general).
gs="gs -q -dBATCH -dAutoRotatePages=/None"
# Can't use -dNODISPLAY because that eliminates split output.

cd CADMUS || cd $tb/CADMUS || exit 1
test -d upload || mkdir upload
rm -f upload/*
cd upload || exit 1

infile=../issue.pdf
pubyear=`date +%y`
pubdate=$pubmonth$pubyear

# how cadmus wants the file names to look.
filesuffix=_TUGboat$pubdate

# 
# split pdf into individual pages.
echo "$0: splitting `pdfpagecount $infile` pages..."

# we redirect stderr from ghostscript, and only display it if exit status
# is bad, because as of around gs 10.0, it started outputting
# 100+ useless (to us) messages like:
# GPL Ghostscript 10.02.0: ERROR: A pdfmark destination page 121 points beyond the last page 1.	
#
gserr=/tmp/gsspliterr
$gs -o "%03d$filesuffix.pdf" -sDEVICE=pdfwrite $infile 2>$gserr
status=$?
if test $status -ne 0; then
  echo "$0: $gs split failed (status $status) in: `pwd`" >&2
  cat $gserr >&2
  exit $status
fi

#ls -l

# make sure we created the expected number of files
# (so must check this before doing covers).
filecount=`ls | wc -l`
echo "$0: $filecount files in: `pwd`"
assert_pdfpagecount $infile $filecount

echo "$0: grayscaling pages, this will take a while ..."
date

# for each page not listed in $colorpages, if it has any color, convert
# to grayscale.
color_count=0
gray_count=0
set - $colorpages # now use word-split $colorpages as argv
for page in `seq --format="%03.0f" 1 $filecount`; do # for every page in doc
  color=false
  origfile=$page$filesuffix.pdf
  if test x$page = x$1; then
    echo "$page: printing in color, converting to CMYK."
    test $# -gt 0 && shift
    color_count=`expr $color_count + 1`
    cmykfile=cmyk-$origfile
    ps2pdf-cmyk-tub $origfile $cmykfile || exit 1
    mv $cmykfile $origfile || exit 1
  else
    # use the inkcov gs device to detect if there's any color on the page.
    colorvals=`$gs -o - -sDEVICE=inkcov $origfile`
    #echo "colorvals for $page: $colorvals"
    page_has_color=false
    for field in 1 2 3; do
      color=`echo $colorvals | awk '{print $1+0}'` # +0 to remove 0 decimals
      #echo "  field 1: $color"
      if test "$color" != 0; then
        page_has_color=true
        break
      fi
    done
    if $page_has_color; then
      echo "$page: color on page but not in colorpages, so grayscaling."
      grayfile=gray-$origfile
      ps2pdf-gray-tub $origfile $grayfile || exit 1
      mv $grayfile $origfile || exit 1
    else
      #echo "$page: no color on page ($colorvals), continuing."
      :
    fi
    gray_count=`expr $gray_count + 1`
  fi
done
date

# should have found all color pages given.
if test $# -ne 0; then
  echo "$0: these color pages specified but not found, goodbye: $*" >&1
  exit 1
fi

echo "$0: $color_count color + $gray_count grayscale  =  $filecount pages."

# 
# Link the covers and the spine, we should not need any changes.
set -x
echo "$0: linking covers ... (in `pwd`)"
for c in 1 2 3 4; do
  dest=c$c$filesuffix.pdf
  echo "$0:   $dest"
  cdest=../cover$c.pdf
  if test ! -s $cdest; then
    echo "$0: cover page not there: $cdest (in `pwd`)"
    exit 1
  fi
  ln -s ../cover$c.pdf $dest || exit 1
  assert_pdfpagecount $dest 1
done

ln -s ../spine.pdf sp$filesuffix.pdf || exit 1
assert_pdfpagecount sp$filesuffix.pdf 1

# Finally, re-concatenate all the pages, so that we have a single file
# we can look through and check that grayscale vs. color came out correctly.
echo "$0: making issue-upload.pdf for manual check ..."
pdfconcat issue-upload.pdf [^cs]*$filesuffix.pdf
assert_pdfpagecount issue-upload.pdf $filecount
ls -l issue-upload.pdf
